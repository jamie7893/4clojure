<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1467911760806">{:repl-history {:ide [], :local [&quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list (first list)))))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list (first list)))) list)\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list* (first list)))) list)\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list* (first list)))) (pop list))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list* (first list)))) (pop (list list)))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list (first list)))) (pop (list list)))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list* (first list)))) (pop (list* list)))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (first list))) (pop (list list)))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (flat (first list)) list)\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (flat (first list)) (pop list))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur new-vec (concat (pop list) (flat list)))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur new-vec (concat (pop list) (flat (first list))))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur new-vec (flat (first list)))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur new-vec (pop list))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (first list))) (pop list))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (empty? list)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (first list))) (pop list))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   (vec new-vec))))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (not-empty list)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (first list))) (pop list))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (not-empty list)\n                   (let [[x]]\n                     (if (coll? x)\n                       (recur (concat new-vec (flat x)) (pop list))\n                       (recur (conj new-vec x) (pop list))))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (not-empty list)\n                   (let [[x] list]\n                     (if (coll? x)\n                       (recur (concat new-vec (flat x)) (pop list))\n                       (recur (conj new-vec x) (pop list))))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (not-empty list)\n                   (let [[x &amp; therest] list]\n                     (if (coll? x)\n                       (recur (concat new-vec (flat x)) therest)\n                       (recur (conj new-vec x) therest)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (not-empty list)\n                   (let [[x] list]\n                     (if (coll? x)\n                       (recur (concat new-vec (flat x)) )\n                       (recur (conj new-vec x) (pop list))))\n                   new-vec)))&quot; &quot;(pop [4 3 5])&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (not-empty list)\n                   (let [[x] list]\n                     (if (coll? x)\n                       (recur (concat new-vec (flat x)) )\n                       (recur (conj new-vec x) (pop list))))\n                   (sort new-vec))))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (not-empty list)\n                   (let [[x &amp; therest] list]\n                     (if (coll? x)\n                       (recur (concat new-vec (flat x)) therest)\n                       (recur (conj new-vec x) therest)))\n                   (sort new-vec))))&quot; &quot;(flat '((1 2) 3 [4 [5 6]]))&quot; &quot;(map (fn [x]\n       (if (= x (.toUpperCase x))\n         \&quot;true\&quot;\n         \&quot;false\&quot;)) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(map (fn [x]\n       x) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(map (fn [x]\n       (if (= x (.toUpperCase (str x)))\n         \&quot;true\&quot;\n         \&quot;false\&quot;)) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(map (fn [x]\n       (if (= (str x) (.toUpperCase (str x)))\n         \&quot;true\&quot;\n         \&quot;false\&quot;)) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(map (fn [x]\n       (if (= (str x) (.toUpperCase (str x)))\n         x\n         \&quot;\&quot;)) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(map (fn [x]\n       (if (= (str x) (.toUpperCase (str x)))\n         (str x)\n         \&quot;\&quot;)) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(map (fn [x]\n       (if (= (str x) (.toUpperCase (str x)))\n         (str x)\n         nil)) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(filter char/isUpperCase \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter .isUpperCase \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter char/.isUpperCase \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter Character.isUpperCase \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter character/isUpperCase \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter Character/.isUpperCase \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter Character/isUpperCase? \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter Character/isUpperCase \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter Character/isUpperCase \\A)&quot; &quot;(map identity \&quot;dksfj\&quot;)&quot; &quot;(filter Character/isUpperCase \&quot;sdkljfkl\&quot;)&quot; &quot;(filter (fn [x] \n          (Character/isUpperCase x)) \&quot;sdkljfkl\&quot;)&quot; &quot;(filter (fn [x] \n          (Character/isUpperCase x)) \&quot;sdKJDSDJkljfkl\&quot;)&quot; &quot;(str (filter (fn [x]\n               (Character/isUpperCase x)) \&quot;sdKJDSDJkljfkl\&quot;))&quot; &quot;(filter (fn [x]\n          (str (Character/isUpperCase x))) \&quot;sdKJDSDJkljfkl\&quot;)&quot; &quot;(filter (fn [x]\n          (Character/isUpperCase (str x))) \&quot;sdKJDSDJkljfkl\&quot;)&quot; &quot;(filter (fn [x]\n          (Character/isUpperCase x)) \&quot;sdKJDSDJkljfkl\&quot;)&quot; &quot;(fn [x]\n  (let [upper-letters (filter (fn [x]\n                                (Character/isUpperCase x))]\n    (str upper-letters)))&quot; &quot;(fn [x]\n  (let [upper-letter (filter (fn [y]\n                               (str (Character/isUpperCase y))) x)]\n    (str upper-letter)))&quot; &quot;(fn [x]\n  (let [upper-letter (filter (fn [y]\n                               (str (Character/isUpperCase y))) x)]\n    upper-letter))&quot; &quot;(fn [x]\n  (let [upper-letter (filter (fn [y]\n                               (str (Character/isUpperCase y))) x \&quot;skjKLSJDFkjs\&quot;)]\n    (str upper-letter)))&quot; &quot;(fn [x]\n  (let [upper-letter (filter (fn [y]\n                               (str (Character/isUpperCase y))) \&quot;skjKLSJDFkjs\&quot;)]\n    (str upper-letter)))&quot; &quot;(fn [x]\n  (let [upper-letter (filter (fn [y]\n                               (str (Character/isUpperCase y))) \&quot;skjKLSJDFkjs\&quot;)]\n    upper-letter))&quot; &quot;(filter (fn [y]\n          (str (Character/isUpperCase y))) \&quot;skjKLSJDFkjs\&quot;)&quot; &quot;(let [upper-cast (filter (fn [y]\n                (str (Character/isUpperCase y))) \&quot;skjKLSJDFkjs\&quot;)]\n  (str upper-cast))&quot; &quot;(let [upper-cast (filter (fn [y]\n                (str (Character/isUpperCase y))) \&quot;skjKLSJDFkjs\&quot;)]\n  (str (upper-cast)))&quot; &quot;(let [upper-cast (filter (fn [y]\n                (str (Character/isUpperCase y))) \&quot;skjKLSJDFkjs\&quot;)]\n  upper-cast)&quot; &quot;(let [upper-cast (filter (fn [y]\n                           (Character/isUpperCase y)) \&quot;skjKLSJDFkjs\&quot;)]\n  upper-cast)&quot; &quot;(let [upper-cast (filter (fn [y]\n                           (Character/isUpperCase y)) \&quot;skjKLSJDFkjs\&quot;)]\n  (str upper-cast))&quot; &quot;(fn [x]\n  (let [upper-letter (filter (fn [y]\n                               (Character/isUpperCase y)) \&quot;skjKLSJDFkjs\&quot;)]\n    upper-letter))&quot; &quot;(fn [x]\n  (let [upper-letter (filter (fn [y]\n                               (Character/isUpperCase y)) \&quot;skjKLSJDFkjs\&quot;)]\n    (char-name-string upper-letter)))&quot; &quot;(map (fn [x]\n       (if (= (str x) (.toUpperCase (str x)))\n         x\n         )) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(fn [x]\n  (loop [cnt 0]\n    (if (= (get [1 2 3 4 5] cnt) nil)\n      cnt\n      (recur (inc cnt)))))&quot; &quot;(loop [cnt 0]\n  (if (= (get [1 2 3 4 5] cnt) nil)\n    cnt\n    (recur (inc cnt))))&quot; &quot;(map (fn [x]\n       (if (= (str x) (.toUpperCase (str x)))\n         (str x)\n         )) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(map (fn [x]\n       (if (= (str x) (.toUpperCase (str x)))\n         (filter identity (str x))\n         )) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(fn [y]\n  (let [the-string (map (fn [x]\n                          (if (= (str x) (.toUpperCase (str x)))\n                            (str x)\n                            )) \&quot;AKskdKAkfsn\&quot;)]\n    (filter identity the-string)))&quot; &quot;(fn [y]\n  (let [the-string (map (fn [x]\n                          (if (= (str x) (.toUpperCase (str x)))\n                            (str x)\n                            )) \&quot;AKskdKAkfsn\&quot;)]\n    (filter identity (the-string))))&quot; &quot;(fn [y]\n  (let [the-string (map (fn [x]\n                          (if (= (str x) (.toUpperCase (str x)))\n                            (str x)\n                            )) \&quot;AKskdKAkfsn\&quot;)]\n    the-string))&quot; &quot;(fn [y]\n  (let [the-string (map (fn [x]\n                          (if (= (str x) (.toUpperCase (str x)))\n                            (str x)\n                            )) \&quot;AKskdKAkfsn\&quot;)]\n    (the-string)))&quot; &quot;(fn [y]\n  (let [the-string (map (fn [x]\n                          (if (= (str x) (.toUpperCase (str x)))\n                            (str x)\n                            )) \&quot;AKskdKAkfsn\&quot;)]\n    ))&quot; &quot;(dedupe \&quot;jjjjj\&quot;)&quot; &quot;(+ 2 (+ 2 1))&quot; &quot;(reduce (+ x (+ x 1)) [1 2 3 4])&quot; &quot;(reduce (fn [x] (+ x (+ x 1))) [1 2 3 4])&quot; &quot;(reduce (fn [x] x) [1 2 3 4])&quot; &quot;(reduce (fn [x prev] x) [1 2 3 4])&quot; &quot;(reduce (fn [x prev] prev) [1 2 3 4])&quot; &quot;(+ (range 20) (range 20))&quot; &quot;(for [[x y] (partition 2 (range 20))]\n  (+ x y))&quot; &quot;(clojure.set/subset? #{1 2})&quot; &quot;(fn [x]\n  (loop [new-list (identity x) old-list (vec x) cnt (count (- old-list 1))]\n    (if (contains? old-list)\n      (recur (conj new-list (nth old-list cnt)) old-list (dec cnt))\n      new-list)))&quot; &quot;(identity [1 2 3 4 5])&quot; &quot;(type [1 2 3 4 5])&quot; &quot;(loop [new-list (identity [1 2 3 4 5]) old-list (vec [1 2 3 4 5]) cnt (count (- old-list 1))]\n  (if (contains? old-list)\n    (recur (conj new-list (nth old-list cnt)) old-list (dec cnt))\n    new-list))&quot; &quot;(loop [new-list (type [1 2 3 4 5]) old-list (vec [1 2 3 4 5]) cnt (count (- old-list 1))]\n  (if (contains? old-list)\n    (recur (conj new-list (nth old-list cnt)) old-list (dec cnt))\n    new-list))&quot; &quot;(loop [new-list [1 2 3 4] old-list (vec [1 2 3 4]) cnt (- (count old-list) 1)]\n  (if (empty? old-list)\n    (recur (conj new-list (nth old-list cnt)) old-list (dec cnt))\n    new-list))&quot; &quot;(loop [new-list [1 2 3 4] old-list (vec [1 2 3 4]) cnt (- (count old-list) 1)]\n  (if (empty? old-list)\n    (recur (cons new-list (nth old-list cnt)) old-list (dec cnt))\n    new-list))&quot; &quot;(loop [new-list [1 2 3 4] old-list (vec [1 2 3 4]) cnt (- (count old-list) 1)]\n  (if (not-empty? old-list)\n    (recur (conj new-list (nth old-list cnt)) old-list (dec cnt))\n    new-list))&quot; &quot;(loop [new-list [1 2 3 4] old-list (vec [1 2 3 4]) cnt (- (count old-list) 1)]\n  (if (not-empty old-list)\n    (recur (conj new-list (nth old-list cnt)) old-list (dec cnt))\n    new-list))&quot; &quot;(loop [new-list (empty [1 2 3 4]) old-list (vec [1 2 3 4]) cnt (- (count old-list) 1)]\n  (if (not-empty old-list)\n    (recur (conj new-list (nth old-list cnt)) old-list (dec cnt))\n    new-list))&quot; &quot;(loop [new-list (empty [1 2 3 4]) old-list (vec [1 2 3 4]) cnt (- (count old-list) 1)]\n  (if (= (count new-list) (count old-list))\n    new-list\n    (recur (conj new-list (nth old-list cnt)) old-list (dec cnt))))&quot; &quot;(fn [x] (loop [new-list (empty x) old-list (vec x) cnt (- (count old-list) 1)]\n          (if (= (count new-list) (count old-list))\n            new-list\n            (recur (conj new-list (nth old-list cnt)) old-list (dec cnt)))))&quot; &quot;(loop [new-list (empty (sorted-set 5 7 2 7)) old-list (vec (sorted-set 5 7 2 7)) cnt (- (count old-list) 1)]\n  (if (= (count new-list) (count old-list))\n    new-list\n    (recur (conj new-list (nth old-list cnt)) old-list (dec cnt))))&quot; &quot;(loop [new-list (empty (sorted-set 5 7 2 7)) old-list (vec (sorted-set 5 7 2 7)) cnt (- (count old-list) 1)]\n  (if (= (count (vec new-list)) (count old-list))\n    new-list\n    (recur (cons new-list (nth old-list cnt)) old-list (dec cnt))))&quot; &quot;(loop [new-list (empty (sorted-set 5 7 2 7)) old-list (vec (sorted-set 5 7 2 7)) cnt (- (count old-list) 1)]\n  (if (= (count (vec new-list)) (count old-list))\n    new-list\n    (recur (conj new-list (nth old-list cnt)) old-list (dec cnt))))&quot; &quot;(loop [new-list [] old-list (vec (sorted-set 5 7 2 7)) cnt (- (count old-list) 1)]\n  (if (= (count (vec new-list)) (count old-list))\n    ((empty x) new-list)\n    (recur (conj new-list (nth old-list cnt)) old-list (dec cnt))))&quot; &quot;(loop [new-list [] old-list (vec (sorted-set 5 7 2 7)) cnt (- (count old-list) 1)]\n  (if (= (count (vec new-list)) (count old-list))\n    ((empty (sorted-set 5 7 2 7)) new-list)\n    (recur (conj new-list (nth old-list cnt)) old-list (dec cnt))))&quot; &quot;(loop [new-list [] old-list (vec (sorted-set 5 7 2 7)) cnt (- (count old-list) 1)]\n  (if (= (count (vec new-list)) (count old-list))\n    new-list\n    (recur (conj new-list (nth old-list cnt)) old-list (dec cnt))))&quot;], :remote []}}</component>
</project>