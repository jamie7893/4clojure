<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1467841425155">{:repl-history {:ide [], :local [&quot;(if (&gt; (count (vec '((1 2) 3 [4 [5 6]]))) 1)\n  (recur (concat (first (vec '((1 2) 3 [4 [5 6]]))) (last (vec '((1 2) 3 [4 [5 6]])))))\n  list)&quot; &quot;(loop [list '((1 2) 3 [4 [5 6]])]\n  (if (&gt; (count (vec list)) 1)\n    (recur (concat (first (vec list)) (last (vec list))))\n    list))&quot; &quot;(loop [list (vec '((1 2) 3 [4 [5 6]]))]\n  (if (&gt; (count (vec list)) 1)\n    (recur (concat (first (vec list)) (last (vec list))))\n    list))&quot; &quot;(loop [list (vec '((1 2) 3 [4 [5 6]]))]\n  (if (&gt; (count list) 1)\n    (recur (concat (first list) (last list)))\n    list))&quot; &quot;(concat (first (vec '((1 2) 3 [4 [5 6]]))) (last (vec '((1 2) 3 [4 [5 6]]))))&quot; &quot;(concat (first (vec '((1 2) 3 [4 [5 6]]))) (rest (vec '((1 2) 3 [4 [5 6]]))))&quot; &quot;(defn flat [list] (map (fn []\n                            ) list))&quot; &quot;(loop [new-v []] \n  (map fn [x]  \n    (if (?coll x)\n      (recur (concat x new-v))\n      (recur (conj new-v x))) \n    (vec '((1 2) 3 [4 [5 6]]))))&quot; &quot;(loop [new-v []] \n  (map fn [x]  \n    (?coll x)\n      (recur (concat x new-v))\n      (recur (conj new-v x))\n    (vec '((1 2) 3 [4 [5 6]]))))&quot; &quot;(loop [new-v []] \n  (map (fn [x]\n         (?coll x)\n         (recur (concat x new-v))\n         (recur (conj new-v x)))\n    (vec '((1 2) 3 [4 [5 6]]))))&quot; &quot;(loop [new-v []] \n  (map (fn [x]\n         (coll? x)\n         (recur (concat x new-v))\n         (recur (conj new-v x)))\n    (vec '((1 2) 3 [4 [5 6]]))))&quot; &quot;(loop [new-v []] \n  (map (fn [x]\n         (if (coll? x)\n           (recur (concat x new-v))\n           (recur (conj new-v x))))\n    (vec '((1 2) 3 [4 [5 6]]))))&quot; &quot;(loop [new-vec [] list '((1 2) 3 [4 [5 6]])]\n  (if (count list)\n    (if (coll? (first list))\n      (recur (concat new-vec (first list)) (pop list))\n      (recur (conj new-vec (first list) (pop list))))\n    new-vec))&quot; &quot;(loop [new-vec [] list '((1 2) 3 [4 [5 6]])]\n  (if (count list)\n    (if (coll? (first list))\n      (recur (concat new-vec (first list)) (pop list))\n      (recur (conj new-vec (first list)) (pop list)))\n    new-vec))&quot; &quot;(loop [new-vec [] list '((1 2) 3 [4 [5 6]])]\n  (if (&gt; (count list) -1)\n    (if (coll? (first list))\n      (recur (concat new-vec (first list)) (pop list))\n      (recur (conj new-vec (first list)) (pop list)))\n    new-vec))&quot; &quot;(loop [new-vec [] list '((1 2) 3 [4 [5 6]])]\n  (if (&gt; (count (vec list)) 0)\n    (if (coll? (first (vec list)))\n      (recur (concat new-vec (first (vec list))) (pop (vec list)))\n      (recur (conj new-vec (first (vec list))) (pop (vec list))))\n    new-vec))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                (if (&gt; (count list) 0)\n                  (if (coll? (first list))\n                    (recur (concat new-vec (first list)) (pop list))\n                    (recur (conj new-vec (first list)) (pop list)))\n                  (map (fn [x]\n                         (if (coll? x)\n                           (flat new-vec)\n                           x)) new-vec))))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                (if (&gt; (count list) 0)\n                  (if (coll? (first list))\n                    (flat (first list))\n                    (recur (conj new-vec (first list)) (pop list)))\n                  new-vec)))&quot; &quot;(mapcat (fn [x]\n          x) '((1 2) 3 [4 [5 6]]))&quot; &quot;(mapcat '((1 2) 3 [4 [5 6]]))&quot; &quot;(mapcat (fn [x]\n          ) '((1 2) 3 [4 [5 6]]))&quot; &quot;(mapcat (fn [x]\n          (x)) '((1 2) 3 [4 [5 6]]))&quot; &quot;(mapcat reverse '((1 2) 3 [4 [5 6]]))&quot; &quot;(defn flat [l] (loop [new-vec '() list l]\n                (if (&gt; (count list) 0)\n                  (if (coll? (first list))\n                    (recur (concat new-vec (flat (first list))) (pop list))\n                    (recur (conj new-vec (first list)) (pop list)))\n                  new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                (if (&gt; (count list) 0)\n                  (if (coll? (first list))\n                    (recur (concat new-vec (flat (first list))) (pop list))\n                    (recur (conj new-vec (first list)) (pop list)))\n                  new-vec)))&quot; &quot;(loop [new-vec [] list '((1 2) 3 [4 [5 6]])]\n  (if (&gt; (count list) 0)\n    (if (coll? (first list))\n      (recur (concat new-vec (first list)) (pop list))\n      (recur (conj new-vec (first list)) (pop list)))\n    new-vec))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (first list)) (pop list))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (first list)) (pop list))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   (count new-vec))))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (first list))) list)\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(flat '(4 (5 6)))&quot; &quot;(coll? [])&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list (first list)))) (pop (list list)))\n                     (recur (conj new-vec (first list)) (pop (list list))))\n                   new-vec)))&quot; &quot;(coll? [4 [5 6]])&quot; &quot;(flat [4 [5 6]])&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list (first list)))) (pop list))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list (first list)))))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list (first list)))) list)\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list* (first list)))) list)\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list* (first list)))) (pop list))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list* (first list)))) (pop (list list)))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list (first list)))) (pop (list list)))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (list* (first list)))) (pop (list* list)))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (first list))) (pop (list list)))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (flat (first list)) list)\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (flat (first list)) (pop list))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur new-vec (concat (pop list) (flat list)))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur new-vec (concat (pop list) (flat (first list))))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur new-vec (flat (first list)))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur new-vec (pop list))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (&gt; (count list) 0)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (first list))) (pop list))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (empty? list)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (first list))) (pop list))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   (vec new-vec))))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (not-empty list)\n                   (if (coll? (first list))\n                     (recur (concat new-vec (flat (first list))) (pop list))\n                     (recur (conj new-vec (first list)) (pop list)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (not-empty list)\n                   (let [[x]]\n                     (if (coll? x)\n                       (recur (concat new-vec (flat x)) (pop list))\n                       (recur (conj new-vec x) (pop list))))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (not-empty list)\n                   (let [[x] list]\n                     (if (coll? x)\n                       (recur (concat new-vec (flat x)) (pop list))\n                       (recur (conj new-vec x) (pop list))))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (not-empty list)\n                   (let [[x &amp; therest] list]\n                     (if (coll? x)\n                       (recur (concat new-vec (flat x)) therest)\n                       (recur (conj new-vec x) therest)))\n                   new-vec)))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (not-empty list)\n                   (let [[x] list]\n                     (if (coll? x)\n                       (recur (concat new-vec (flat x)) )\n                       (recur (conj new-vec x) (pop list))))\n                   new-vec)))&quot; &quot;(pop [4 3 5])&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (not-empty list)\n                   (let [[x] list]\n                     (if (coll? x)\n                       (recur (concat new-vec (flat x)) )\n                       (recur (conj new-vec x) (pop list))))\n                   (sort new-vec))))&quot; &quot;(defn flat [l] (loop [new-vec [] list l]\n                 (if (not-empty list)\n                   (let [[x &amp; therest] list]\n                     (if (coll? x)\n                       (recur (concat new-vec (flat x)) therest)\n                       (recur (conj new-vec x) therest)))\n                   (sort new-vec))))&quot; &quot;(flat '((1 2) 3 [4 [5 6]]))&quot; &quot;(map (fn [x]\n       (if (= x (.toUpperCase x))\n         \&quot;true\&quot;\n         \&quot;false\&quot;)) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(map (fn [x]\n       x) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(map (fn [x]\n       (if (= x (.toUpperCase (str x)))\n         \&quot;true\&quot;\n         \&quot;false\&quot;)) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(map (fn [x]\n       (if (= (str x) (.toUpperCase (str x)))\n         \&quot;true\&quot;\n         \&quot;false\&quot;)) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(map (fn [x]\n       (if (= (str x) (.toUpperCase (str x)))\n         x\n         \&quot;\&quot;)) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(map (fn [x]\n       (if (= (str x) (.toUpperCase (str x)))\n         (str x)\n         \&quot;\&quot;)) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(map (fn [x]\n       (if (= (str x) (.toUpperCase (str x)))\n         (str x)\n         nil)) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(filter char/isUpperCase \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter .isUpperCase \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter char/.isUpperCase \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter Character.isUpperCase \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter character/isUpperCase \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter Character/.isUpperCase \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter Character/isUpperCase? \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter Character/isUpperCase \&quot;KJSnkdlsfjKLJS\&quot;)&quot; &quot;(filter Character/isUpperCase \\A)&quot; &quot;(map identity \&quot;dksfj\&quot;)&quot; &quot;(filter Character/isUpperCase \&quot;sdkljfkl\&quot;)&quot; &quot;(filter (fn [x] \n          (Character/isUpperCase x)) \&quot;sdkljfkl\&quot;)&quot; &quot;(filter (fn [x] \n          (Character/isUpperCase x)) \&quot;sdKJDSDJkljfkl\&quot;)&quot; &quot;(str (filter (fn [x]\n               (Character/isUpperCase x)) \&quot;sdKJDSDJkljfkl\&quot;))&quot; &quot;(filter (fn [x]\n          (str (Character/isUpperCase x))) \&quot;sdKJDSDJkljfkl\&quot;)&quot; &quot;(filter (fn [x]\n          (Character/isUpperCase (str x))) \&quot;sdKJDSDJkljfkl\&quot;)&quot; &quot;(filter (fn [x]\n          (Character/isUpperCase x)) \&quot;sdKJDSDJkljfkl\&quot;)&quot; &quot;(fn [x]\n  (let [upper-letters (filter (fn [x]\n                                (Character/isUpperCase x))]\n    (str upper-letters)))&quot; &quot;(fn [x]\n  (let [upper-letter (filter (fn [y]\n                               (str (Character/isUpperCase y))) x)]\n    (str upper-letter)))&quot; &quot;(fn [x]\n  (let [upper-letter (filter (fn [y]\n                               (str (Character/isUpperCase y))) x)]\n    upper-letter))&quot; &quot;(fn [x]\n  (let [upper-letter (filter (fn [y]\n                               (str (Character/isUpperCase y))) x \&quot;skjKLSJDFkjs\&quot;)]\n    (str upper-letter)))&quot; &quot;(fn [x]\n  (let [upper-letter (filter (fn [y]\n                               (str (Character/isUpperCase y))) \&quot;skjKLSJDFkjs\&quot;)]\n    (str upper-letter)))&quot; &quot;(fn [x]\n  (let [upper-letter (filter (fn [y]\n                               (str (Character/isUpperCase y))) \&quot;skjKLSJDFkjs\&quot;)]\n    upper-letter))&quot; &quot;(filter (fn [y]\n          (str (Character/isUpperCase y))) \&quot;skjKLSJDFkjs\&quot;)&quot; &quot;(let [upper-cast (filter (fn [y]\n                (str (Character/isUpperCase y))) \&quot;skjKLSJDFkjs\&quot;)]\n  (str upper-cast))&quot; &quot;(let [upper-cast (filter (fn [y]\n                (str (Character/isUpperCase y))) \&quot;skjKLSJDFkjs\&quot;)]\n  (str (upper-cast)))&quot; &quot;(let [upper-cast (filter (fn [y]\n                (str (Character/isUpperCase y))) \&quot;skjKLSJDFkjs\&quot;)]\n  upper-cast)&quot; &quot;(let [upper-cast (filter (fn [y]\n                           (Character/isUpperCase y)) \&quot;skjKLSJDFkjs\&quot;)]\n  upper-cast)&quot; &quot;(let [upper-cast (filter (fn [y]\n                           (Character/isUpperCase y)) \&quot;skjKLSJDFkjs\&quot;)]\n  (str upper-cast))&quot; &quot;(fn [x]\n  (let [upper-letter (filter (fn [y]\n                               (Character/isUpperCase y)) \&quot;skjKLSJDFkjs\&quot;)]\n    upper-letter))&quot; &quot;(fn [x]\n  (let [upper-letter (filter (fn [y]\n                               (Character/isUpperCase y)) \&quot;skjKLSJDFkjs\&quot;)]\n    (char-name-string upper-letter)))&quot; &quot;(map (fn [x]\n       (if (= (str x) (.toUpperCase (str x)))\n         x\n         )) \&quot;AKskdKAkfsn\&quot;)&quot; &quot;(map (fn [x]\n       (if (= (str x) (.toUpperCase (str x)))\n         (str x)\n         )) \&quot;AKskdKAkfsn\&quot;)&quot;], :remote []}}</component>
</project>